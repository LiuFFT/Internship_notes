# MySQL 相关知识总结

## MySQL架构

重点是有几层架构，哪部分是区别于其他的。

- 连接层：connection pool
- 服务层：查询、解析、分析、优化、缓存。跨存储引擎功能在此实现
- 存储引擎层：真正的负责了MySQL中数据的存储和提取
- 文件系统层

![image-20210223112412833](https://tva1.sinaimg.cn/large/008eGmZEly1gnxazsmac9j312s0nq42j.jpg)


>MySQL一条SQL语句如何执行


 客户端请求 ---> 连接器（验证身份，给权限）--->查询缓存（有就直接返回，没有就执行后续）--->分析器（词法分析、语法分析）--->优化器（对执行的sql优化选择最优的执行方案）---> 执行器（看有无权限，有就操作引擎，返回结果）--->在引擎层获取数据返回（有缓存还要缓存数据）

![image-20210223113541864](https://tva1.sinaimg.cn/large/008eGmZEly1gnxbbplwo0j312s0t60wd.jpg)



## 存储引擎

存储引擎是MySQL的组件，不同的存储引擎有不同的索引技巧、存储机制和锁定级别。**一个数据库中的多个表可以使用不同的引擎以满足不同的需求。**

### 存储引擎对比

#### 文件存储结构

| 不同点   | MyISAM                                                   | InnoDB                                           |
| -------- | -------------------------------------------------------- | ------------------------------------------------ |
| 物理结构 | .frm: 存表结构的<br />.myd: 存数据的<br />.myi: 存索引的 | .frm: 存表结构的<br />.ibd: 存数据和索引的<br /> |
| 主外键   | 无                                                       | 有                                               |
| 事务     | 不支持                                                   | 支持                                             |
| 行表锁   | 表锁，并发程度低                                         | 行锁                                             |
| 缓存     | 只缓存索引                                               | 缓存索引和数据                                   |
| 表空间   | 小                                                       | 大                                               |

MyISAM 会把自增主键的最大ID记录到数据文件中，重启不会丢失。



> select count(*) 

MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。

InnoDB要全表扫描统计数量

## 数据类型

过

## 索引

索引**是帮助MySQL高效获取数据的数据结构**， 本质是**数据结构**

目的是为了实现高效的查询，提高查询效率。

-- 索引本身也很大，一般存在磁盘而不是内存



### 索引的优势和劣势

#### 优势

- 提高数据检索效率，降低数据库IO成本
- 降低数据排序的成本，降低CPU的消耗

#### 劣势

- 索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存
- 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。



### 索引的类型

#### **数据结构角度**

- B+
- Full-Text全文索引
- hash
- R-tree索引

#### **从物理存储角度**

- 聚簇索引
- 非聚簇索引

#### **从逻辑角度**

- 主键索引
- 普通索引
- 多列索引
- 唯一索引
- 空间索引



### **MySQL索引结构**

B+树

先讲B-树：每个节点中不仅包含数据的key值，还有data值。

![image-20210223173241603](https://tva1.sinaimg.cn/large/008eGmZEly1gnxln5d9fzj314e0eenep.jpg)

**B+树** 是B-树的优化

**所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上**，非叶子节点只包含key，不含数据。

B+Tree相对于B-Tree有几点不同：

1. 非叶子节点只存储键值信息；
2. 所有叶子节点之间都有一个链指针；
3. 数据记录都存放在叶子节点中

![img](https://tva1.sinaimg.cn/large/008eGmZEly1gnxls4914cj31400evjtd.jpg)

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。MySQL的InnoDB存储引擎在设计时是将**根节点常驻内存的**，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。



**最左前缀匹配原则：**在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。



#### **MyISAM主键索引与辅助索引的结构**

MyISAM引擎的索引文件和数据文件是分离的。**MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址**。索引文件与数据文件分离，这样的索引称为"**非聚簇索引**"。MyISAM的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字。

![image-20210223174803559](https://tva1.sinaimg.cn/large/008eGmZEly1gnxm361dgyj312e0o277g.jpg)

在MyISAM中，索引（含叶子节点）存放在单独的.myi文件中，叶子节点存放的是数据的物理地址偏移量。



#### **InnoDB主键索引与辅助索引的结构**

**InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录**（对于主索引，此处会存放表中所有的数据记录，对于辅助索引，此处会引用主键，检索的时候通过主键到主索引中找到对应的数据行）——**回表查询**。**InnoDB的数据文件本身就是主键索引文件**，这样的索引被称为"“聚簇索引”，一个表只能有一个聚簇索引。

##### 主键索引

![image-20210223175114463](https://tva1.sinaimg.cn/large/008eGmZEly1gnxm6gttb7j30xc0fqq4j.jpg)



##### 辅助索引

![image-20210223175225874](https://tva1.sinaimg.cn/large/008eGmZEly1gnxm7ouxf3j30xg0fsq4a.jpg)

以示例中学生表中的name列建立辅助索引，对name列进行条件搜索，需要两个步骤（**回表查询**）：

- 在辅助索引上检索name，到达叶子节点，获取到对应的主键
- 在主键索引中使用获取到的主键查数据



InnoDB 索引结构需要注意的点

1. 数据文件本身就是索引文件
2. 表数据文件本身就是按 B+Tree 组织的一个索引结构文件
3. 聚集索引中叶节点包含了完整的数据记录
4. InnoDB 表必须要有主键，并且推荐使用整型自增主键



## MySQL查询

> count(*) 和 count(1)和count(列名)区别

执行结果：

count(*) 和 count(1)不会忽略列值为NULL

count(列名)忽略列值为null，即某个字段值为NULL时，不统计。

执行效率：

1. 列名为主键，count(列名)会比count(1)快
2. 列名不为主键，count(1)会比count(列名)快
3. 如果表多个列并且没有主键，则 count(1) 的执行效率优于 count(*)
4. 如果有主键，则 select count（主键）的执行效率是最优的
5. 如果表只有一个字段，则 select count(*) 最优。

#### SQL执行顺序

![image-20210223180751305](https://tva1.sinaimg.cn/large/008eGmZEly1gnxmnommbbj311g0b410t.jpg)